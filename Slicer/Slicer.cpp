#define LENGTHPRECISION 0.01
#define ANGLEPRECISION 0.25
#define _USE_MATH_DEFINES
#define _CRT_SECURE_NO_WARNINGS
#include <fstream>
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <ctime>
#include <cv.h>

using namespace std;

vector<CvMat> layerdata;
vector<vector<CvPoint2D32f>> rawlayerdata;
vector<float> height;
vector<string> code;

//默认输入元素按z的大小排序->添加排序
//默认同一层z完全一致->精度转换
//尚未添加填充参数(非全满填充 etc.)
//尚未根据半径变化修改打印速度
//部分gcode未添加
//未考虑上下两层overlap的程度
//精度float->(double)
//判断精度与代码输出精度分离；


//
	//逐层打印->逐半径打印

ostream& operator<<(ostream& out, CvPoint3D32f& pt) {
	out << "(" << pt.x << "," << pt.y << "," << pt.z << ")";
	return out;
}

ostream& operator<<(ostream& out, CvPoint2D32f& pt) {
	out << "(" << pt.x << "," << pt.y << ")" ;
	return out;
}

double deg2rad(double degree) {
	return (degree / 180 * M_PI);
}

string DoubleToString(double d)
{
	using namespace std;
	string str;
	stringstream ss;
	ss << d;
	ss >> str;
	return str;
}

void generateTime() {
	time_t time_timet;
	struct tm* time_tm;
	time(&time_timet);
	time_tm = localtime(&time_timet);
	char buffer[30];
	strftime(buffer, 30, "%F %T", time_tm);
	string timestring(buffer);
	timestring = "; generated by slicer at " + timestring;
	code.push_back(timestring);
}

void toLayer(vector<CvPoint3D32f>& pt) {
	
	if (pt.empty()) return;
	double currentZ = pt[0].z;
	int j = -1;
	vector<CvPoint2D32f> temp;
	for (int i = 0; i < pt.size(); i++) {
		if (pt[i].z == currentZ) {
			temp.push_back(CvPoint2D32f(pt[i].x, pt[i].y));
		}
		else {
			rawlayerdata.push_back(temp);
			temp.clear();
			currentZ = pt[i].z;
			++j;
			temp.push_back(CvPoint2D32f(pt[i].x, pt[i].y));
			height.push_back(pt[i].z);
		}
	}
	rawlayerdata.push_back(temp);
	height.push_back(currentZ);
	for (int i = 0; i < rawlayerdata.size(); i++){
		CvMat mat = cvMat(rawlayerdata[i].size(), 2, CV_32FC1, &rawlayerdata[i][0]);
		layerdata.push_back(mat);
	}
}

void recentralize() {
	CvBox2D temp_rect;
	CvPoint2D32f center(0, 0);
	int count = 0;
	//float area;
	for (int i = 0; i < layerdata.size(); i++)
	{
		if (layerdata[i].rows >= 5) {
			temp_rect = cvFitEllipse2(&layerdata[i]);
			center.x += temp_rect.center.x;
			center.y += temp_rect.center.y;
			//area = cvContourArea(&layerdata[i]);
			count++;
		}
	}
	center.x /= count;
	center.y /= count;
	for (int i = 0; i < layerdata.size(); i++) {
		CvMat* pmat = &(layerdata[i]);
		for (int j = 0; j < pmat->rows; j++) {
			pmat->data.fl[j * pmat->cols + 0] -= center.x;
			pmat->data.fl[j * pmat->cols + 1] -= center.y;
		}
	}
	float ground = height[0];
	for (int i = 0; i < height.size(); i++)
		height[i] -= ground;
}

void generateLayerCode(CvMat& layer) {
	CvPoint2D32f center;
	//static float length=0; 记录总长度
	float radius,maxRadius,minRadius;
	int printedPoints=0;
	vector<string> layercode;
	//bool flag = false;
	bool newradius = true;
	string temp_code;
	cvMinEnclosingCircle(&layer, &center, &radius);
	maxRadius = radius + sqrt(center.x*center.x + center.y*center.y);
	minRadius = sqrt(center.x*center.x + center.y*center.y) - radius;
	radius = maxRadius;
	while (radius >= max((float)0,minRadius)) {
		for (float angle = 0; angle < 360; angle += ANGLEPRECISION)
		{
			CvPoint2D32f testedpoint;
			testedpoint.x = radius*cos(deg2rad(angle));
			testedpoint.y = radius*sin(deg2rad(angle));
			if (cvPointPolygonTest(&layer, testedpoint, 1)> -0.01) {//添加判断 如果点列过少不予打印
				printedPoints++;
				if (newradius){
					temp_code = "G1 X" + DoubleToString(radius) + " Y" + DoubleToString(deg2rad(angle));
					//length+=angle*=radius;
					newradius = false;
				}
				else{
					temp_code = "G1 Y" + DoubleToString(deg2rad(angle));
				}
				code.push_back(temp_code);
			}
			else {
				printedPoints = 0;
				newradius = true;
			}
		}
		radius -= LENGTHPRECISION; //中心点
		newradius = true;
	}
}

void generateCode() {
	//添加开始、停止打印代码
	generateTime();
	string temp_code;
	for (int i = 0; i < layerdata.size(); i++) {
		temp_code ="G1 X" + DoubleToString(0) + " Y" + DoubleToString(0) + " Z" + DoubleToString(height[i]);
		code.push_back(temp_code);
		generateLayerCode(layerdata[i]);
	}
}

bool input(string filename, vector<CvPoint3D32f>& vec) {
	ifstream inFile;
	inFile.open(filename);
	if (inFile.fail())
		return false;
	double temp_x, temp_y, temp_z;
	while (!inFile.eof())
	{
		inFile >> temp_x >> temp_y >> temp_z;
		vec.push_back(CvPoint3D32f(temp_x, temp_y, temp_z));
	}
	inFile.close();
	return true;
}

bool output(string filename,vector<string>& code){
	ofstream outFile;
	string newfilename(filename, 0, filename.size() - 4);
	newfilename = newfilename + ".gcode";
	outFile.open(newfilename);
	if (outFile.fail())
		return false;
	for (int i = 0; i < code.size(); i++){
		outFile << code[i] << endl;
	}
	return true;	
}



int main() {
	vector<CvPoint3D32f> rawpoints;
	ofstream outFile;
	string filename;
	cin >> filename;
	if(!input(filename,rawpoints)) return -1;
	toLayer(rawpoints);
	recentralize();
	generateCode();
	if (!output(filename, code)) return -1;
	return 0;
}
