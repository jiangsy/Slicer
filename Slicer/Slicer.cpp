#define LENGTHPRECISION 0.4
#define ANGLEPRECISION 0.2
#define MINIMUMPRINTEDPOINTS 3
#define LAYERHEIGHT 0.3
#define _USE_MATH_DEFINES
#define _CRT_SECURE_NO_WARNINGS
#include <fstream>
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <ctime>
#include <cv.h>


using namespace std;

string filename;
ofstream outFile;
vector<CvMat> layerdata;
vector<vector<CvPoint2D32f>> rawlayerdata;
vector<float> height;
vector<string> code;
float length = 0;

//默认输入元素按z的大小排序->添加排序
	//默认z间隔相同 ->添加线性插值
//默认同一层z完全一致->精度转换
//尚未添加填充参数(非全满填充 etc.)
//尚未根据半径变化修改打印速度
//未考虑上下两层overlap的程度
//精度float->(double)
//判断精度与代码输出精度分离；

void print() {
	for (int i = 0; i < code.size(); i++) {
		outFile << code[i] << endl;
	}
}

ostream& operator<<(ostream& out, CvPoint3D32f& pt) {
	out << "(" << pt.x << "," << pt.y << "," << pt.z << ")";
	return out;
}

ostream& operator<<(ostream& out, CvPoint2D32f& pt) {
	out << "(" << pt.x << "," << pt.y << ")";
	return out;
}

double deg2rad(double degree) {
	return (degree / 180 * M_PI);
}

string DoubleToString(double d)
{
	using namespace std;
	string str;
	stringstream ss;
	ss << d;
	ss >> str;
	return str;
}

string IntToString(int i)
{
	using namespace std;
	string str;
	stringstream ss;
	ss << i;
	ss >> str;
	return str;
}

void generateTime() {
	time_t time_timet;
	struct tm* time_tm;
	time(&time_timet);
	time_tm = localtime(&time_timet);
	char buffer[30];
	strftime(buffer, 30, "%F %T", time_tm);
	string timestring(buffer);
	timestring = "; generated by slicer at " + timestring;
	code.push_back(timestring);
}

void toLayer(vector<CvPoint3D32f>& pt) {

	if (pt.empty()) return;
	double currentZ = pt[0].z;
	int j = -1;
	vector<CvPoint2D32f> temp;
	for (int i = 0; i < pt.size(); i++) {
		if (pt[i].z == currentZ) {
			temp.push_back(CvPoint2D32f(pt[i].x, pt[i].y));
		}
		else {
			rawlayerdata.push_back(temp);
			temp.clear();
			currentZ = pt[i].z;
			++j;
			temp.push_back(CvPoint2D32f(pt[i].x, pt[i].y));
			height.push_back(pt[i].z);
		}
	}
	rawlayerdata.push_back(temp);
	height.push_back(currentZ);
	for (int i = 0; i < rawlayerdata.size(); i++) {
		CvMat mat = cvMat(rawlayerdata[i].size(), 2, CV_32FC1, &rawlayerdata[i][0]);
		layerdata.push_back(mat);
	}
	pt.clear();
}

void recentralize() {

	CvBox2D temp_rect;
	CvPoint2D32f center(0, 0);
	int count = 0;
	//float area;
	for (int i = 0; i < layerdata.size(); i++)
	{
		if (layerdata[i].rows >= 5) {
			temp_rect = cvFitEllipse2(&layerdata[i]);
			center.x += temp_rect.center.x;
			center.y += temp_rect.center.y;
			//area = cvContourArea(&layerdata[i]);
			count++;
		}
	}
	center.x /= count;
	center.y /= count;
	for (int i = 0; i < layerdata.size(); i++) {
		CvMat* pmat = &(layerdata[i]);
		for (int j = 0; j < pmat->rows; j++) {
			pmat->data.fl[j * pmat->cols + 0] -= center.x;
			pmat->data.fl[j * pmat->cols + 1] -= center.y;
		}
	}
	float ground = height[0];
	for (int i = 0; i < height.size(); i++)
		height[i] -= ground;
}

void generateLayerCode(CvMat& layer) {
	CvPoint2D32f center;
	//float layerLength = 0;
	float radius, maxRadius, minRadius;
	int printedPoints = 0;
	vector<string> layercode;
	//bool flag = false;
	bool newradius = true;
	string temp_code;
	cvMinEnclosingCircle(&layer, &center, &radius);
	maxRadius = radius + sqrt(center.x*center.x + center.y*center.y);
	minRadius = sqrt(center.x*center.x + center.y*center.y) - radius;
	radius = maxRadius;
	while (radius >= max((float)0, minRadius)) {
		for (float angle = 0; angle < 360; angle += ANGLEPRECISION)
		{
			CvPoint2D32f testedpoint;
			testedpoint.x = radius*cos(deg2rad(angle));
			testedpoint.y = radius*sin(deg2rad(angle));
			if (cvPointPolygonTest(&layer, testedpoint, 1)> -0.01) {//添加判断 如果点列过少不予打印
				printedPoints++;
				if (newradius) {
					temp_code = "G1 X" + DoubleToString(radius) + " Y" + DoubleToString(angle) + " E" + DoubleToString(length*LAYERHEIGHT)+ " F"+ IntToString(1500);
					newradius = false;
				}
				else {
					temp_code = "G1 Y" + DoubleToString(angle)+" E" + DoubleToString(length*LAYERHEIGHT);
				}
				layercode.push_back(temp_code);
			}
			else {
				if (layercode.size() >= MINIMUMPRINTEDPOINTS) {
					for (int i = 0; i < layercode.size(); i++) {
						length += radius*ANGLEPRECISION;
						
					}
					code.push_back(layercode[0]);
					code.push_back(layercode[layercode.size()-1]);
				}
				layercode.clear();
				printedPoints = 0;
				newradius = true;
			}
		}
		if (layercode.size() >= MINIMUMPRINTEDPOINTS) {
			for (int i = 0; i < layercode.size(); i++) {
				length += radius*ANGLEPRECISION;
			}
			code.push_back(layercode[0]);
			code.push_back(layercode[layercode.size() - 1]);
		}
		layercode.clear();
		radius -= LENGTHPRECISION; //中心点
		newradius = true;
	}
}

void generateInit() {
	code.push_back("G21; set units to millimeters");
	code.push_back("M107");
	code.push_back("M104 S200; set temperature");
	code.push_back("G92 X0 Y0");
	code.push_back("G28 Z");
	code.push_back("G1 Z10");
	code.push_back("G28 X");
	code.push_back("G28 Z");
	code.push_back("G1 Z4.8; Z axis set zero");
	code.push_back("G92 Z0");
	code.push_back("M109 S200; wait for temperature to be reached");
	code.push_back("G90; use absolute coordinates");
	code.push_back("M82; use absolute distances for extrusion");
	code.push_back("G0 X94");
	code.push_back("G92 E0 X0; X axis set zero");
}

void generateCode() {
	//添加开始、停止打印代码
	generateTime();
	generateInit();
	string temp_code;
	for (int i = 0; i < layerdata.size(); i++) {
		temp_code = "G1 X" + DoubleToString(0) + " Y" + DoubleToString(0) + " Z" + DoubleToString(height[i]);
		code.push_back(temp_code);
		generateLayerCode(layerdata[i]);
		print();
		code.clear();
	}
}

bool input(string filename, vector<CvPoint3D32f>& vec) {
	ifstream inFile;
	inFile.open(filename);
	if (inFile.fail())
		return false;
	double temp_x, temp_y, temp_z;
	while (!inFile.eof())
	{
		inFile >> temp_x >> temp_y >> temp_z;
		vec.push_back(CvPoint3D32f(temp_x, temp_y, temp_z));
	}
	inFile.close();
	return true;
}

bool output(string filename) {
	
	string newfilename(filename, 0, filename.size() - 4);
	newfilename = newfilename + ".gcode";
	outFile.open(newfilename);
	if (outFile.fail())
		return false;
	return true;
}



int main() {
	vector<CvPoint3D32f> rawpoints;
	cin >> filename;
	if (!input(filename, rawpoints)) return -1;
	if (!output(filename)) return -1;
	toLayer(rawpoints);
	recentralize();
	generateCode();
	outFile.close();
	return 0;
}
